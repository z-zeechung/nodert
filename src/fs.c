
/**
 * THIS FILE WAS AUTO GENERATED BY ``
 * RUN `` TO REGENERATE THIS FILE
 */

#include "fs.h"
#include "fs.inc"

#include <quickjs.h>
#include <errno.h>
#include "types.h"
#include "event_queue.h"



struct fs_access_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    char* var0;
    int32_t var1;

    JSValue cb;
    int errnum;
};

static void fs_access_wrapper_event(struct fs_access_wrapper_payload* payload) {
    char* var0 = payload->var0;
    int32_t var1 = payload->var1;

    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_UNDEFINED;

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    JS_FreeCString(ctx, var0);

    if (payload->errnum == 0) {
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_access_wrapper_worker(
    struct fs_access_wrapper_payload* payload) {
    errno = 0;
    fs_access(payload->var0, payload->var1);
    payload->errnum = errno;
}

static JSValue fs_access_wrapper(JSContext* ctx, JSValueConst this_val,
                                 int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    int32_t var1;
    JS_ToInt32(ctx, &var1, argv[1]);

    struct fs_access_wrapper_payload* payload =
        (struct fs_access_wrapper_payload*)malloc(
            sizeof(struct fs_access_wrapper_payload));

    payload->var0 = var0;
    payload->var1 = var1;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[2]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_access_wrapper_worker, payload,
                                fs_access_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_accessSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                     int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    int32_t var1;
    JS_ToInt32(ctx, &var1, argv[1]);

    errno = 0;
    fs_access(var0, var1);
    if (errno != 0) {  // TODO

        JS_FreeCString(ctx, var0);

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_UNDEFINED;

    JS_FreeCString(ctx, var0);

    return js_retval;
}



static JSValue fs_existsSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                     int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    errno = 0;
    bool retval = fs_exists(var0);
    if (errno != 0) {  // TODO

        JS_FreeCString(ctx, var0);

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_NewBool(ctx, retval);

    JS_FreeCString(ctx, var0);

    return js_retval;
}




struct fs_open_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    char* var0;
    int32_t var1;
    int32_t var2;
    int32_t retval;
    JSValue cb;
    int errnum;
};

static void fs_open_wrapper_event(struct fs_open_wrapper_payload* payload) {
    char* var0 = payload->var0;
    int32_t var1 = payload->var1;
    int32_t var2 = payload->var2;
    int32_t retval = payload->retval;
    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_NewInt32(ctx, retval);

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    JS_FreeCString(ctx, var0);

    if (payload->errnum == 0) {
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_open_wrapper_worker(struct fs_open_wrapper_payload* payload) {
    errno = 0;
    payload->retval = fs_open(payload->var0, payload->var1, payload->var2);
    payload->errnum = errno;
}

static JSValue fs_open_wrapper(JSContext* ctx, JSValueConst this_val, int argc,
                               JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    int32_t var1;
    JS_ToInt32(ctx, &var1, argv[1]);

    int32_t var2;
    JS_ToInt32(ctx, &var2, argv[2]);

    struct fs_open_wrapper_payload* payload =
        (struct fs_open_wrapper_payload*)malloc(
            sizeof(struct fs_open_wrapper_payload));

    payload->var0 = var0;
    payload->var1 = var1;
    payload->var2 = var2;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[3]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_open_wrapper_worker, payload,
                                fs_open_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_openSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                   int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    int32_t var1;
    JS_ToInt32(ctx, &var1, argv[1]);

    int32_t var2;
    JS_ToInt32(ctx, &var2, argv[2]);

    errno = 0;
    int32_t retval = fs_open(var0, var1, var2);
    if (errno != 0) {  // TODO

        JS_FreeCString(ctx, var0);

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_NewInt32(ctx, retval);

    JS_FreeCString(ctx, var0);

    return js_retval;
}




struct fs_close_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    int32_t var0;

    JSValue cb;
    int errnum;
};

static void fs_close_wrapper_event(struct fs_close_wrapper_payload* payload) {
    int32_t var0 = payload->var0;

    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_UNDEFINED;

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    if (payload->errnum == 0) {
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_close_wrapper_worker(struct fs_close_wrapper_payload* payload) {
    errno = 0;
    fs_close(payload->var0);
    payload->errnum = errno;
}

static JSValue fs_close_wrapper(JSContext* ctx, JSValueConst this_val, int argc,
                                JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    struct fs_close_wrapper_payload* payload =
        (struct fs_close_wrapper_payload*)malloc(
            sizeof(struct fs_close_wrapper_payload));

    payload->var0 = var0;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[1]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_close_wrapper_worker, payload,
                                fs_close_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_closeSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                    int argc, JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    errno = 0;
    fs_close(var0);
    if (errno != 0) {  // TODO

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_UNDEFINED;

    return js_retval;
}




struct fs_read_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    int32_t var0;
    array_buffer var1;
    int64_t var2;
    int64_t var3;
    int64_t var4;
    int64_t retval;
    JSValue cb;
    int errnum;
};

static void fs_read_wrapper_event(struct fs_read_wrapper_payload* payload) {
    int32_t var0 = payload->var0;
    array_buffer var1 = payload->var1;
    int64_t var2 = payload->var2;
    int64_t var3 = payload->var3;
    int64_t var4 = payload->var4;
    int64_t retval = payload->retval;
    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_NewInt64(ctx, retval);

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    if (payload->errnum == 0) {
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_read_wrapper_worker(struct fs_read_wrapper_payload* payload) {
    errno = 0;
    payload->retval = fs_read(payload->var0, payload->var1, payload->var2,
                              payload->var3, payload->var4);
    payload->errnum = errno;
}

static JSValue fs_read_wrapper(JSContext* ctx, JSValueConst this_val, int argc,
                               JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    array_buffer var1;
    var1.data = JS_GetArrayBuffer(ctx, &(var1.size), argv[1]);

    int64_t var2;
    JS_ToInt64(ctx, &var2, argv[2]);

    int64_t var3;
    JS_ToInt64(ctx, &var3, argv[3]);

    int64_t var4;
    JS_ToInt64(ctx, &var4, argv[4]);

    struct fs_read_wrapper_payload* payload =
        (struct fs_read_wrapper_payload*)malloc(
            sizeof(struct fs_read_wrapper_payload));

    payload->var0 = var0;
    payload->var1 = var1;
    payload->var2 = var2;
    payload->var3 = var3;
    payload->var4 = var4;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[5]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_read_wrapper_worker, payload,
                                fs_read_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_readSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                   int argc, JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    array_buffer var1;
    var1.data = JS_GetArrayBuffer(ctx, &(var1.size), argv[1]);

    int64_t var2;
    JS_ToInt64(ctx, &var2, argv[2]);

    int64_t var3;
    JS_ToInt64(ctx, &var3, argv[3]);

    int64_t var4;
    JS_ToInt64(ctx, &var4, argv[4]);

    errno = 0;
    int64_t retval = fs_read(var0, var1, var2, var3, var4);
    if (errno != 0) {  // TODO

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_NewInt64(ctx, retval);

    return js_retval;
}




struct fs_readFileUtf8_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    char* var0;
    int32_t var1;
    char* retval;
    JSValue cb;
    int errnum;
};

static void fs_readFileUtf8_wrapper_event(
    struct fs_readFileUtf8_wrapper_payload* payload) {
    char* var0 = payload->var0;
    int32_t var1 = payload->var1;
    char* retval = payload->retval;
    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_NewStringLen(ctx, retval, strlen(retval));

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    JS_FreeCString(ctx, var0);

    if (payload->errnum == 0) {
        if (retval) {
            free(retval);
        }
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_readFileUtf8_wrapper_worker(
    struct fs_readFileUtf8_wrapper_payload* payload) {
    errno = 0;
    payload->retval = fs_read_file_utf8(payload->var0, payload->var1);
    payload->errnum = errno;
}

static JSValue fs_readFileUtf8_wrapper(JSContext* ctx, JSValueConst this_val,
                                       int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    int32_t var1;
    JS_ToInt32(ctx, &var1, argv[1]);

    struct fs_readFileUtf8_wrapper_payload* payload =
        (struct fs_readFileUtf8_wrapper_payload*)malloc(
            sizeof(struct fs_readFileUtf8_wrapper_payload));

    payload->var0 = var0;
    payload->var1 = var1;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[2]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_readFileUtf8_wrapper_worker, payload,
                                fs_readFileUtf8_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_readFileUtf8Sync_wrapper(JSContext* ctx,
                                           JSValueConst this_val, int argc,
                                           JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    int32_t var1;
    JS_ToInt32(ctx, &var1, argv[1]);

    errno = 0;
    char* retval = fs_read_file_utf8(var0, var1);
    if (errno != 0) {  // TODO

        JS_FreeCString(ctx, var0);

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_NewStringLen(ctx, retval, strlen(retval));

    JS_FreeCString(ctx, var0);

    if (retval) {
        free(retval);
    }

    return js_retval;
}




struct fs_rename_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    char* var0;
    char* var1;

    JSValue cb;
    int errnum;
};

static void fs_rename_wrapper_event(struct fs_rename_wrapper_payload* payload) {
    char* var0 = payload->var0;
    char* var1 = payload->var1;

    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_UNDEFINED;

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    JS_FreeCString(ctx, var0);

    JS_FreeCString(ctx, var1);

    if (payload->errnum == 0) {
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_rename_wrapper_worker(
    struct fs_rename_wrapper_payload* payload) {
    errno = 0;
    fs_rename(payload->var0, payload->var1);
    payload->errnum = errno;
}

static JSValue fs_rename_wrapper(JSContext* ctx, JSValueConst this_val,
                                 int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    const char* var1 = JS_ToCString(ctx, argv[1]);

    struct fs_rename_wrapper_payload* payload =
        (struct fs_rename_wrapper_payload*)malloc(
            sizeof(struct fs_rename_wrapper_payload));

    payload->var0 = var0;
    payload->var1 = var1;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[2]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_rename_wrapper_worker, payload,
                                fs_rename_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_renameSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                     int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    const char* var1 = JS_ToCString(ctx, argv[1]);

    errno = 0;
    fs_rename(var0, var1);
    if (errno != 0) {  // TODO

        JS_FreeCString(ctx, var0);

        JS_FreeCString(ctx, var1);

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_UNDEFINED;

    JS_FreeCString(ctx, var0);

    JS_FreeCString(ctx, var1);

    return js_retval;
}




struct fs_ftruncate_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    int32_t var0;
    int64_t var1;

    JSValue cb;
    int errnum;
};

static void fs_ftruncate_wrapper_event(
    struct fs_ftruncate_wrapper_payload* payload) {
    int32_t var0 = payload->var0;
    int64_t var1 = payload->var1;

    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_UNDEFINED;

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    if (payload->errnum == 0) {
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_ftruncate_wrapper_worker(
    struct fs_ftruncate_wrapper_payload* payload) {
    errno = 0;
    fs_ftruncate(payload->var0, payload->var1);
    payload->errnum = errno;
}

static JSValue fs_ftruncate_wrapper(JSContext* ctx, JSValueConst this_val,
                                    int argc, JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    int64_t var1;
    JS_ToInt64(ctx, &var1, argv[1]);

    struct fs_ftruncate_wrapper_payload* payload =
        (struct fs_ftruncate_wrapper_payload*)malloc(
            sizeof(struct fs_ftruncate_wrapper_payload));

    payload->var0 = var0;
    payload->var1 = var1;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[2]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_ftruncate_wrapper_worker, payload,
                                fs_ftruncate_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_ftruncateSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                        int argc, JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    int64_t var1;
    JS_ToInt64(ctx, &var1, argv[1]);

    errno = 0;
    fs_ftruncate(var0, var1);
    if (errno != 0) {  // TODO

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_UNDEFINED;

    return js_retval;
}




struct fs_rmdir_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    char* var0;

    JSValue cb;
    int errnum;
};

static void fs_rmdir_wrapper_event(struct fs_rmdir_wrapper_payload* payload) {
    char* var0 = payload->var0;

    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_UNDEFINED;

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    JS_FreeCString(ctx, var0);

    if (payload->errnum == 0) {
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_rmdir_wrapper_worker(struct fs_rmdir_wrapper_payload* payload) {
    errno = 0;
    fs_rmdir(payload->var0);
    payload->errnum = errno;
}

static JSValue fs_rmdir_wrapper(JSContext* ctx, JSValueConst this_val, int argc,
                                JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    struct fs_rmdir_wrapper_payload* payload =
        (struct fs_rmdir_wrapper_payload*)malloc(
            sizeof(struct fs_rmdir_wrapper_payload));

    payload->var0 = var0;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[1]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_rmdir_wrapper_worker, payload,
                                fs_rmdir_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_rmdirSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                    int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    errno = 0;
    fs_rmdir(var0);
    if (errno != 0) {  // TODO

        JS_FreeCString(ctx, var0);

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_UNDEFINED;

    JS_FreeCString(ctx, var0);

    return js_retval;
}




struct fs_fsync_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    int32_t var0;

    JSValue cb;
    int errnum;
};

static void fs_fsync_wrapper_event(struct fs_fsync_wrapper_payload* payload) {
    int32_t var0 = payload->var0;

    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_UNDEFINED;

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    if (payload->errnum == 0) {
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_fsync_wrapper_worker(struct fs_fsync_wrapper_payload* payload) {
    errno = 0;
    fs_fsync(payload->var0);
    payload->errnum = errno;
}

static JSValue fs_fsync_wrapper(JSContext* ctx, JSValueConst this_val, int argc,
                                JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    struct fs_fsync_wrapper_payload* payload =
        (struct fs_fsync_wrapper_payload*)malloc(
            sizeof(struct fs_fsync_wrapper_payload));

    payload->var0 = var0;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[1]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_fsync_wrapper_worker, payload,
                                fs_fsync_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_fsyncSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                    int argc, JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    errno = 0;
    fs_fsync(var0);
    if (errno != 0) {  // TODO

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_UNDEFINED;

    return js_retval;
}




struct fs_fdatasync_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    int32_t var0;

    JSValue cb;
    int errnum;
};

static void fs_fdatasync_wrapper_event(
    struct fs_fdatasync_wrapper_payload* payload) {
    int32_t var0 = payload->var0;

    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_UNDEFINED;

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    if (payload->errnum == 0) {
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_fdatasync_wrapper_worker(
    struct fs_fdatasync_wrapper_payload* payload) {
    errno = 0;
    fs_fdatasync(payload->var0);
    payload->errnum = errno;
}

static JSValue fs_fdatasync_wrapper(JSContext* ctx, JSValueConst this_val,
                                    int argc, JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    struct fs_fdatasync_wrapper_payload* payload =
        (struct fs_fdatasync_wrapper_payload*)malloc(
            sizeof(struct fs_fdatasync_wrapper_payload));

    payload->var0 = var0;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[1]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_fdatasync_wrapper_worker, payload,
                                fs_fdatasync_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_fdatasyncSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                        int argc, JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    errno = 0;
    fs_fdatasync(var0);
    if (errno != 0) {  // TODO

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_UNDEFINED;

    return js_retval;
}




struct fs_readdir_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    char* var0;
    string_array retval;
    JSValue cb;
    int errnum;
};

static void fs_readdir_wrapper_event(
    struct fs_readdir_wrapper_payload* payload) {
    char* var0 = payload->var0;
    string_array retval = payload->retval;
    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_NewArray(ctx);
    for (int i = 0; i < retval.count; i++) {
        JS_SetPropertyUint32(
            ctx, js_retval, i,
            JS_NewStringLen(ctx, retval.strs[i], strlen(retval.strs[i])));
    }

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    JS_FreeCString(ctx, var0);

    if (payload->errnum == 0) {
        if (retval.strs) {
            for (int i = 0; i < retval.count; i++) {
                free(retval.strs[i]);
            }
            free(retval.strs);
        }
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_readdir_wrapper_worker(
    struct fs_readdir_wrapper_payload* payload) {
    errno = 0;
    payload->retval = fs_readdir(payload->var0);
    payload->errnum = errno;
}

static JSValue fs_readdir_wrapper(JSContext* ctx, JSValueConst this_val,
                                  int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    struct fs_readdir_wrapper_payload* payload =
        (struct fs_readdir_wrapper_payload*)malloc(
            sizeof(struct fs_readdir_wrapper_payload));

    payload->var0 = var0;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[1]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_readdir_wrapper_worker, payload,
                                fs_readdir_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_readdirSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                      int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    errno = 0;
    string_array retval = fs_readdir(var0);
    if (errno != 0) {  // TODO

        JS_FreeCString(ctx, var0);

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_NewArray(ctx);
    for (int i = 0; i < retval.count; i++) {
        JS_SetPropertyUint32(
            ctx, js_retval, i,
            JS_NewStringLen(ctx, retval.strs[i], strlen(retval.strs[i])));
    }

    JS_FreeCString(ctx, var0);

    if (retval.strs) {
        for (int i = 0; i < retval.count; i++) {
            free(retval.strs[i]);
        }
        free(retval.strs);
    }

    return js_retval;
}




struct fs_fstat_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    int32_t var0;
    int64_array retval;
    JSValue cb;
    int errnum;
};

static void fs_fstat_wrapper_event(struct fs_fstat_wrapper_payload* payload) {
    int32_t var0 = payload->var0;
    int64_array retval = payload->retval;
    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_NewArray(ctx);
    for (int i = 0; i < retval.count; i++) {
        JS_SetPropertyUint32(ctx, js_retval, i,
                             JS_NewInt64(ctx, retval.data[i]));
    }

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    if (payload->errnum == 0) {
        if (retval.data) {
            free(retval.data);
        }
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_fstat_wrapper_worker(struct fs_fstat_wrapper_payload* payload) {
    errno = 0;
    payload->retval = fs_fstat(payload->var0);
    payload->errnum = errno;
}

static JSValue fs_fstat_wrapper(JSContext* ctx, JSValueConst this_val, int argc,
                                JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    struct fs_fstat_wrapper_payload* payload =
        (struct fs_fstat_wrapper_payload*)malloc(
            sizeof(struct fs_fstat_wrapper_payload));

    payload->var0 = var0;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[1]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_fstat_wrapper_worker, payload,
                                fs_fstat_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_fstatSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                    int argc, JSValueConst* argv) {
    int32_t var0;
    JS_ToInt32(ctx, &var0, argv[0]);

    errno = 0;
    int64_array retval = fs_fstat(var0);
    if (errno != 0) {  // TODO

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_NewArray(ctx);
    for (int i = 0; i < retval.count; i++) {
        JS_SetPropertyUint32(ctx, js_retval, i,
                             JS_NewInt64(ctx, retval.data[i]));
    }

    if (retval.data) {
        free(retval.data);
    }

    return js_retval;
}




struct fs_lstat_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    char* var0;
    int64_array retval;
    JSValue cb;
    int errnum;
};

static void fs_lstat_wrapper_event(struct fs_lstat_wrapper_payload* payload) {
    char* var0 = payload->var0;
    int64_array retval = payload->retval;
    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_NewArray(ctx);
    for (int i = 0; i < retval.count; i++) {
        JS_SetPropertyUint32(ctx, js_retval, i,
                             JS_NewInt64(ctx, retval.data[i]));
    }

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    JS_FreeCString(ctx, var0);

    if (payload->errnum == 0) {
        if (retval.data) {
            free(retval.data);
        }
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_lstat_wrapper_worker(struct fs_lstat_wrapper_payload* payload) {
    errno = 0;
    payload->retval = fs_lstat(payload->var0);
    payload->errnum = errno;
}

static JSValue fs_lstat_wrapper(JSContext* ctx, JSValueConst this_val, int argc,
                                JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    struct fs_lstat_wrapper_payload* payload =
        (struct fs_lstat_wrapper_payload*)malloc(
            sizeof(struct fs_lstat_wrapper_payload));

    payload->var0 = var0;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[1]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_lstat_wrapper_worker, payload,
                                fs_lstat_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_lstatSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                    int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    errno = 0;
    int64_array retval = fs_lstat(var0);
    if (errno != 0) {  // TODO

        JS_FreeCString(ctx, var0);

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_NewArray(ctx);
    for (int i = 0; i < retval.count; i++) {
        JS_SetPropertyUint32(ctx, js_retval, i,
                             JS_NewInt64(ctx, retval.data[i]));
    }

    JS_FreeCString(ctx, var0);

    if (retval.data) {
        free(retval.data);
    }

    return js_retval;
}




struct fs_stat_wrapper_payload {
    JSContext* ctx;
    JSValueConst this_val;
    char* var0;
    int64_array retval;
    JSValue cb;
    int errnum;
};

static void fs_stat_wrapper_event(struct fs_stat_wrapper_payload* payload) {
    char* var0 = payload->var0;
    int64_array retval = payload->retval;
    JSContext* ctx = payload->ctx;

    JSValue js_retval = JS_NewArray(ctx);
    for (int i = 0; i < retval.count; i++) {
        JS_SetPropertyUint32(ctx, js_retval, i,
                             JS_NewInt64(ctx, retval.data[i]));
    }

    JSValue returns[2];
    if (payload->errnum != 0) {  // TODO
        returns[0] = JS_NewError(ctx);
        returns[1] = JS_UNDEFINED;
    } else {
        returns[0] = JS_UNDEFINED;
        returns[1] = js_retval;
    }
    JS_Call(payload->ctx, payload->cb, payload->this_val, 2, returns);

    JS_FreeCString(ctx, var0);

    if (payload->errnum == 0) {
        if (retval.data) {
            free(retval.data);
        }
    }

    JS_FreeValue(ctx, payload->cb);
    free(payload);
}

static void fs_stat_wrapper_worker(struct fs_stat_wrapper_payload* payload) {
    errno = 0;
    payload->retval = fs_stat(payload->var0);
    payload->errnum = errno;
}

static JSValue fs_stat_wrapper(JSContext* ctx, JSValueConst this_val, int argc,
                               JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    struct fs_stat_wrapper_payload* payload =
        (struct fs_stat_wrapper_payload*)malloc(
            sizeof(struct fs_stat_wrapper_payload));

    payload->var0 = var0;
    payload->ctx = ctx;
    payload->this_val = this_val;
    payload->cb = JS_DupValue(ctx, argv[1]);
    payload->errnum = 0;

    push_to_generic_event_queue(fs_stat_wrapper_worker, payload,
                                fs_stat_wrapper_event);

    return JS_UNDEFINED;
}



static JSValue fs_statSync_wrapper(JSContext* ctx, JSValueConst this_val,
                                   int argc, JSValueConst* argv) {
    const char* var0 = JS_ToCString(ctx, argv[0]);

    errno = 0;
    int64_array retval = fs_stat(var0);
    if (errno != 0) {  // TODO

        JS_FreeCString(ctx, var0);

        return JS_ThrowInternalError(ctx, "errno is not 0");
    }

    JSValue js_retval = JS_NewArray(ctx);
    for (int i = 0; i < retval.count; i++) {
        JS_SetPropertyUint32(ctx, js_retval, i,
                             JS_NewInt64(ctx, retval.data[i]));
    }

    JS_FreeCString(ctx, var0);

    if (retval.data) {
        free(retval.data);
    }

    return js_retval;
}


#define countof(arr) (sizeof(arr) / sizeof(*arr))

static const JSCFunctionListEntry bindings_funcs[] = {
   JS_CFUNC_DEF("access", 3, fs_access_wrapper),
   JS_CFUNC_DEF("accessSync", 2, fs_accessSync_wrapper),
   JS_CFUNC_DEF("existsSync", 1, fs_existsSync_wrapper),
   JS_CFUNC_DEF("open", 4, fs_open_wrapper),
   JS_CFUNC_DEF("openSync", 3, fs_openSync_wrapper),
   JS_CFUNC_DEF("close", 2, fs_close_wrapper),
   JS_CFUNC_DEF("closeSync", 1, fs_closeSync_wrapper),
   JS_CFUNC_DEF("read", 6, fs_read_wrapper),
   JS_CFUNC_DEF("readSync", 5, fs_readSync_wrapper),
   JS_CFUNC_DEF("readFileUtf8", 3, fs_readFileUtf8_wrapper),
   JS_CFUNC_DEF("readFileUtf8Sync", 2, fs_readFileUtf8Sync_wrapper),
   JS_CFUNC_DEF("rename", 3, fs_rename_wrapper),
   JS_CFUNC_DEF("renameSync", 2, fs_renameSync_wrapper),
   JS_CFUNC_DEF("ftruncate", 3, fs_ftruncate_wrapper),
   JS_CFUNC_DEF("ftruncateSync", 2, fs_ftruncateSync_wrapper),
   JS_CFUNC_DEF("rmdir", 2, fs_rmdir_wrapper),
   JS_CFUNC_DEF("rmdirSync", 1, fs_rmdirSync_wrapper),
   JS_CFUNC_DEF("fsync", 2, fs_fsync_wrapper),
   JS_CFUNC_DEF("fsyncSync", 1, fs_fsyncSync_wrapper),
   JS_CFUNC_DEF("fdatasync", 2, fs_fdatasync_wrapper),
   JS_CFUNC_DEF("fdatasyncSync", 1, fs_fdatasyncSync_wrapper),
   JS_CFUNC_DEF("readdir", 2, fs_readdir_wrapper),
   JS_CFUNC_DEF("readdirSync", 1, fs_readdirSync_wrapper),
   JS_CFUNC_DEF("fstat", 2, fs_fstat_wrapper),
   JS_CFUNC_DEF("fstatSync", 1, fs_fstatSync_wrapper),
   JS_CFUNC_DEF("lstat", 2, fs_lstat_wrapper),
   JS_CFUNC_DEF("lstatSync", 1, fs_lstatSync_wrapper),
   JS_CFUNC_DEF("stat", 2, fs_stat_wrapper),
   JS_CFUNC_DEF("statSync", 1, fs_statSync_wrapper),
};

static int bindings_module_init(JSContext *ctx, JSModuleDef *m) {
    return JS_SetModuleExportList(ctx, m, bindings_funcs, countof(bindings_funcs));
}

JSModuleDef *js_init_fs_bindings(JSContext *ctx, const char *module_name) {
    JSModuleDef *m = JS_NewCModule(ctx, module_name, bindings_module_init);
    if (!m) return NULL;
    
    JS_AddModuleExportList(ctx, m, bindings_funcs, countof(bindings_funcs));
    
    return m;
}
